# -*- coding: utf-8 -*-
"""Assignment #7: Functions

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1RlOsfu6LBgOKOVNoJ8zBI4Y1MOecuR-g

**Def for dice winning probability:**
"""

def calc_dice_craps():
    """
    This function will calculate the probability of rolling two six sided dice that either matches the bet value or exceeds it.

     Input:
     win_bet_value = target value to win bet
     num_dice = number of dice in the game
     num_dice_sides = number of sides on the dice

     Output:
     probability of reaching the target value or exceeding the target value

    """

    # user enters num_dice, num_sides, and their bet:
    num_dice = int(input("\n\nEnter the number of dice: "))
    num_dice_sides = int(input("Enter the number of sides on the dice: "))
    win_bet_val = int(input("Enter your betting value: "))

    # Check for valid input
    if num_dice <= 0 or num_dice_sides <= 0:
        print("You can't make a bet if you're not rolling any dice ....")
        return

    # this is to calculate the number of total outcomes based on the number of dice and the number of sides:
    possible_dice_outcomes = num_dice_sides ** num_dice

    # initialize the number of winning outcomes
    winning_outcomes = 0

    # now to calculate the number of ways the winning outcomes can be acheived from the number of sides and number of dice and winning bet value: *ADD 1 = INCLUSIVE*
    for outcome in range(win_bet_val, num_dice * num_dice_sides + 1):
        # update winning outcome count:
        winning_outcomes += 1

    # calculate the probability of winning = winning outcomes / all outcomes
    probability = winning_outcomes / possible_dice_outcomes

    print("_____________________________________________________")
    print("The probability of winning your bet is: ", probability)
    print("_____________________________________________________")
    return probability

# for number of ways to win:
# 1:
# for loop to get all outcomes = i in range(start: number_dice --> (1 + sides * number_dice)
#2:
# outcomes <= number of dice then multiple by the number of sides // 2 to split into winning and losing categories
    #*****ADD 1 TO INCLUDE THE STARTING VALUE******
#3:
# then the number of ways to get winning role outcome = outcome (<= num_dice) - the number of dice **ADD ONE OR IT WON'T WORK*******
# else if outcome >= number of dice, then the ways to win = the number of dice * the number of sides (*ADD ONE OR IT WONT WORK*) - the outcome from the first for loop
   # so then the number of ways to get winning outcome will = (variable in else statement)
#4:
#total probability = all outcomes / winning outcomes

"""**def for set combinations:**"""

def set_combinations():
  """
  this will generate every combination of characters in a given set (or list) of characters.

  Inputs:
  set = string of characters or values

  Variables:
  'j' = position in user_string
  'i' = iteration variable

  Output:
  All combinations of items in the set (i'm putting them into a list)
  """
  # user inputs the string:
  user_string = input("Enter the string of characters: ")

  # innitialize the list with combinations to be empty before the for loop:
  combinations_list = []
  # for all combinations, you have to do 2 ^ n which is the number of characters in the set (n):
  num_characters = len(user_string)
  all_possible_combinations = 2**num_characters

  # for loop to find all the possible combinations within the given set of characters:
  for i in range(all_possible_combinations):
    # innitialize the combinations string to be empty until the end of calculations:
    str_combos = ""
    # this is to calculate the sets of characters:
    # basically it's to see if the iteration chracter is a set or chracter to be included in the combinations:               #**WILL NOT WORK IF YOU USE OTHER ITERATION VARIABLE NAMES**
    for j in range(num_characters): # j = position in the set
      if i & (1 << j): # i = iteration variable from 0 -> 2 ^n(num_chars), to move through the positions (j) and to not include 0 in combinations to keep list iterating:
        str_combos += user_string[j] # add string position (j) to list of combinations as calculated above, and excluding 0 values

    # to combine all the values of combinations into a single list, you use the append function + combinations to fill the empty list: (don't know how else to do it other than appending)
    combinations_list.append(str_combos)

  # to return the combination list:
  return combinations_list

"""MAIN"""

while True:
  # for user to chose the program
  program_choice = input("Enter the program you would like to run: ('d' for dice probability or 'c' for set combinations: )")

  # in case user enters an invalid program choice
  if program_choice != 'd' and program_choice != 'c':
    print("Invalid choice. Please try again. ")
    continue

  # FOR CRAPS DICE PROBABILITY:
  elif program_choice == 'd':
    while True:
      calc_dice_craps()
      run_craps = input("Run again? ('y/n'):")
      if run_craps != 'y':
        break

  # FOR THE SET COMBINATIONS:
  elif program_choice == 'c':
    # this is to reference the function to correctly print all the combinations
    all_combinations = set_combinations()
    # REF COMBO STRING TO PRINT OUTSIDE OF FUNCTION:
    for str_combos in all_combinations:
      print(str_combos)

  # invlaid choice
  else:
    print("invalid choice. Please try again. /n")
    continue

# run program again (while loop)
  run_program_again = input("Would you like to run the program again? ('y' for yes, 'stop' to exit): ")
  if run_program_again != 'y':
    break